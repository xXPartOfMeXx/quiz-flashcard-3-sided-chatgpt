<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <meta charset="UTF-8">
  <title>√îN T·∫¨P FLASHCARD 3 M·∫∂T - T·ª∞ LU·∫¨N</title>
  <style>
@keyframes wrongBoom {
  0%   { transform: scale(1) rotate(0deg); }
  15%  { transform: scale(1.05) rotate(3deg); }
  30%  { transform: scale(1.1) rotate(-3deg); }
  45%  { transform: scale(1.15) rotate(3deg); }
  60%  { transform: scale(1.15) rotate(-3deg); }
  75%  { transform: scale(1.05) rotate(1deg); }
  100% { transform: scale(1) rotate(0deg); }
}

.shake-rotate-scale {
  animation: wrongBoom 0.45s ease;
  transform-origin: center center;
}

/****************************
 üåô GLOBAL THEME (Dark Neon Cyan)
****************************/
:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #1a2333;
  --surface3: #334155;
  --cyan: #38bdf8;
  --cyan-soft: rgba(56,189,248,0.4);
  --cyan-glow: rgba(56,189,248,0.6);

  --red: #ef4444;
  --yellow: #f1e432;
  --purple: #ae58ff;

  --text-light: #f8fafc;
  --text-soft: #94a3b8;
  --gray-border: #475569;
}
.feedback {
  white-space: pre-wrap;  /* gi·ªØ xu·ªëng d√≤ng khi c√≥ \n */
  font-weight: bold;
}

body {
  font-family: Arial, sans-serif;
  background: var(--bg);
  color: var(--text-light);
  margin: 30px;
}

h1, h2, p, span, label {
  color: var(--text-light);
}

a {
  color: var(--cyan);
  text-decoration: none;
}
a:hover {
  color: #0ea5e9;
}

/****************************
 üåô BUTTONS
****************************/
button, #confirmReplay {
  background-color: var(--surface2);
  color: var(--cyan);
  border: 1px solid var(--cyan);
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 1rem;
  font-weight: bold;
  margin: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 0 8px var(--cyan-soft);
}
button:hover, #confirmReplay:hover{
  transform: scale(1.05);
  background-color: var(--bg);
  box-shadow: 0 0 12px var(--cyan-glow);
}

button:disabled, #confirmReplay:disabled{
  background-color: var(--surface2);
  border-color: var(--gray-border);
  color: #9ca3af;
  opacity: 0.55;
  cursor: not-allowed;
  box-shadow: none;
}
button:disabled:hover {
  transform: none;
  background-color: #0f1520;
}

/* Color variants */
button.red-btn,
#resetMappingBtn,
#popupReset, #cancelReplay {
  background-color: var(--surface2);
  color: var(--red);
  border: 1px solid var(--red);
  box-shadow: 0 0 8px rgba(239,68,68,0.3);
}
button.red-btn:hover,
#resetMappingBtn:hover,
#popupReset:hover, #cancelReplay:hover{
  background-color: #1a0b0b;
  box-shadow: 0 0 12px rgba(239,68,68,0.6);
}

button.purple-btn,
#popupDefault  {
  background-color: var(--surface2);
  color: var(--purple);
  border: 1px solid var(--purple);
  box-shadow: 0 0 8px rgba(174,88,255,0.4);
}
button.purple-btn:hover,
#popupDefault:hover {
  background-color: #170f1f;
  box-shadow: 0 0 12px rgba(174,88,255,0.6);
}

button.yellow-btn,
.github-btn {
  background-color: var(--surface2);
  color: var(--yellow);
  border: 1px solid var(--yellow);
  box-shadow: 0 0 8px rgba(241,228,50,0.3);
}
button.yellow-btn:hover,
.github-btn:hover {
  background-color: #4c4704;
  box-shadow: 0 0 12px rgba(241,228,50,0.6);
}

/****************************
 üåô INPUTS
****************************/
input[type="number"],
input[type="file"],
input.answer-input,
#replayLimit,
#replayTime,
#replayAttempts {
  background: var(--surface);
  border: 1px solid var(--gray-border);
  border-radius: 6px;
  color: var(--text-light);
  padding: 8px 10px;
  font-size: 1rem;
}
input:focus {
  outline: none;
  border-color: var(--cyan);
  background: var(--surface2);
}

/****************************
 üåô QUESTION BOXES
****************************/
.question-box {
  background: var(--surface);
  padding: 20px;
  margin-bottom: 15px;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(56,189,248,0.1);
}

.answer-input {
  width: 97%;
  padding: 12px;
  font-size: 1.3rem;
}

/****************************
 üåô DRAG‚ÄìDROP MAPPING UI
****************************/
.face,
.popup-face {
  background: var(--surface);
  color: var(--cyan);
  border: 1px solid var(--cyan);
  border-radius: 6px;
  padding: 8px 14px;
  font-weight: bold;
  cursor: grab;
  user-select: none;
  transition: 0.2s;
  box-shadow: 0 0 6px var(--cyan-soft);
}
.face:hover,
.popup-face:hover {
  background: var(--bg);
  transform: scale(1.05);
}
.face.used,
.popup-face.used {
  background: #475569 !important;
  color: #94a3b8 !important;
  cursor: not-allowed !important;
  opacity: 0.6;
}

.drop-zone,
.popup-zone {
  width: 170px;
  height: 60px;
  background: var(--surface2);
  border: 2px dashed var(--gray-border);
  border-radius: 8px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight: bold;
  color: var(--text-light);
  transition: all 0.2s;
}
.drop-zone.dragover,
.popup-zone.dragover {
  background: var(--bg);
  border-color: var(--cyan);
}
.drop-zone.filled,
.popup-zone.filled {
  background: #14532d;
  border-color: #22c55e;
  border-style: solid;
}

/****************************
 üåô TIMER
****************************/
#timerDisplay {
  position: fixed;
  top: 20px;
  right: 30px;
  background: var(--surface);
  border: 2px solid var(--cyan);
  color: var(--cyan);
  padding: 10px 15px;
  border-radius: 10px;
  font-size: 1.8rem;
  font-weight: bold;
  z-index: 1000;
  box-shadow: 0 0 12px var(--cyan-soft);
}

/****************************
 üåô SCORE BOX
****************************/
#scoreBox {
  background: var(--surface);
  color: var(--cyan);
  padding: 15px;
  margin-top: 30px;
  border-radius: 10px;
  box-shadow: 0 0 10px var(--cyan-soft);
  font-weight: bold;
  display: none;
}

/****************************
 üåô REPLAY BUTTON
****************************/
.replay-btn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 100px;
  height: 100px;
  font-size: 4rem;
  border: none;
  background: none;
  color: var(--cyan);
  cursor: pointer;
  z-index: 1000;
  opacity: 0.9;
  transition: all 0.2s ease;
  box-shadow: none;
}
.replay-btn:hover {
  transform: scale(1.1);
}

/****************************
 üåô POPUP OVERLAY
****************************/
#replayOverlay {
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(3px);
}

#replayOverlay .popup-box,
#replayOverlay #popup {
  color: var(--text-light);
  padding: 20px 25px;
  border-radius: 10px;
  box-shadow: 0 0 20px var(--cyan-soft);
}

.rednotething {
  color: #ef4444;
  font-weight: bold;
  font-style: italic;
}

.subtitle {
  font-size: 0.9rem;
  color: #94a3b8;
  font-style: italic;
  margin-bottom: 15px;
  margin-left: 20px;
}


#upload {
  display: inline-block !important;
  transform-origin: center center;
  will-change: transform;
  background-color: #1a2333;
  color: #38bdf8;
  border: 1px solid #38bdf8;
  border-radius: 8px;
  padding: 10px 16px;
  font-size: 1rem;
  margin: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 0 8px rgba(56,189,248,0.3);
}
#upload:hover {
  transform: scale(1.05) !important;
  background-color: #0f172a !important;
  box-shadow: 0 0 12px rgba(56,189,248,0.6);
}
#resetBtn:hover, #replayBtn:hover {
  background: none;
  box-shadow: none;
}
  </style>
</head>
<body>

<button id="resetBtn" title="Reset (B·∫°n ph·∫£i upload l·∫°i file!)" style="display:none; position:fixed; font-size:3.5rem; background:none; border:none; box-shadow:none; color:#007bff; cursor:pointer; z-index:1000; opacity:0.9; top:20px; left:48%">üîÑ</button>

<button onclick="window.open('https://github.com/xXPartOfMeXx/quiz-flashcard-3-sided-chatgpt/tree/main', '_blank')"
        class = "yellow-btn">
  üíª GitHub Page of this site
</button>

<h1 id="mainTitle" style="text-align:center;">√îN T·∫¨P FLASHCARD 3 M·∫∂T - T·ª∞ LU·∫¨N</h1>

<div id="setupSection">
<p class="subtitle">
    Ch·ªçn s·ªë c√¢u h·ªèi v√† th·ªùi gian l√†m b√†i r·ªìi t·∫£i l√™n file [*.csv] ƒë·ªÉ b·∫Øt ƒë·∫ßu.
  </p>
  <p class="rednotething">
    T·∫°o v√† ch·ªânh s·ª≠a flashcard 3 m·∫∑t
    <a href="https://xxpartofmexx.github.io/3faceflashcard-creator/" target="_blank">t·∫°i ƒë√¢y</a>.
    (h·ªó tr·ª£ ƒëi·ªán tho·∫°i nh∆∞ng x·∫•u...)
  </p>
  <label style="margin-left:20px;" for="limitInput">S·ªë c√¢u h·ªèi:</label>
  <input type="number" id="limitInput" min="1" style="width:70px"><br><br>
  <label style="margin-left:20px;" for="timeInput">Th·ªùi gian l√†m b√†i (ph√∫t):</label>
  <input type="number" id="timeInput" min="0.1" step="0.1" style="width:80px"><br><br>
  <label style="margin-left: 20px;">S·ªë l·∫ßn th·ª≠ m·ªói c√¢u:</label>
  <input type="number" id="attemptInputWriting" min="1" value="1" style="width: 70px;">

  <p style="font-size:1.2rem; margin-left:20px;">
    <label for="csvFile" id="upload">T·∫£i l√™n file .csv üìÇ</label>
    <input type="file" id="csvFile" accept=".csv" style="display:none;">
  </p>

  <p id="importStatus" title = "Gh√©p h·∫øt c√°c m·∫∑t ƒë·ªÅ b·∫Øt ƒë·∫ßu" style="margin-left: 20px; font-weight:bold; color:lime; font-size:1.1rem;"></p>
  <div style="margin-left:20px; margin-top:10px;">
    <button id="startBtn" style="display: none;">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu</button>
  </div>
</div>

<div id="columnSelector" style="display:none; margin-left:20px; margin-top:10px;">
  <p style="font-weight:bold;">üß© K√©o th·∫£ ƒë·ªÉ ch·ªçn m·∫∑t t∆∞∆°ng ·ª©ng:</p>
  <div id="faces" style="display:flex; gap:10px; margin-bottom:10px;">
    <div class="face" draggable="true" data-index="0">Face 1</div>
    <div class="face" draggable="true" data-index="1">Face 2</div>
    <div class="face" draggable="true" data-index="2">Face 3</div>
  </div>

  <div id="targets" style="display:flex; flex-wrap:wrap; gap:15px;">
    <div class="drop-zone" data-role="question">üß† C√¢u h·ªèi</div>
    <div class="drop-zone" data-role="answer">üí¨ ƒê√°p √°n</div>
    <div class="drop-zone" data-role="definition">üìò Gi·∫£i th√≠ch</div>
    <div style="margin-top:10px;"></div>
      </div>
  <div>
  <br>
  <button id="defaultMappingBtn"
          class = "purple-btn">
    ‚úÖ Default Mapping
  </button>
  <button id="resetMappingBtn"
          class = "red-btn"">
    üîÅ Reset Mapping
  </button>
  </div>



</div>
<div id="quiz"></div>
<div id="scoreBox"></div>
<h2 id="timerDisplay" style="display:none;">‚è±Ô∏è 00:00</h2>
<button id="replayBtn" class="replay-btn" style="display:none;" title="Ch∆°i l·∫°i">üîÅ</button>

<script>
let dataSet = [];
let wrongQuestions = [];
let timerInterval, quizEnded = false, remainingSeconds = 0, quizStartTime;
let correctCountGlobal = 0, totalQuestionsGlobal = 0;
let lastCSVData = null;
let fileNameGlobal = "";

// Simple CSV parser
function parseCSV(text) {
  const rows = [];
  let insideQuotes = false, field = "", row = [];
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === '"') insideQuotes = !insideQuotes;
    else if (c === ',' && !insideQuotes) { row.push(field); field = ""; }
    else if ((c === '\n' || c === '\r') && !insideQuotes) {
      if (field || row.length) { row.push(field); rows.push(row); row = []; field = ""; }
      if (c === '\r' && text[i + 1] === '\n') i++;
    } else field += c;
  }
  if (field || row.length) { row.push(field); rows.push(row); }
  return rows;
}

// ========== Drag-drop mapping with one-to-one assignment + reset ==========
let roleMap = {}; // {question: 0, answer: 1, definition: 2}

function initDragDrop() {
  const faces = document.querySelectorAll('.face');
  const zones = document.querySelectorAll('.drop-zone');
  const resetBtn = document.getElementById("resetMappingBtn");

  // Reset all
  roleMap = {};
  zones.forEach(z => {
    z.textContent = z.dataset.role === "question" ? "üß† C√¢u h·ªèi" :
                    z.dataset.role === "answer" ? "üí¨ ƒê√°p √°n" :
                    "üìò Gi·∫£i th√≠ch";
    z.classList.remove("filled");
  });
  faces.forEach(f => {
    f.classList.remove("used");
    f.draggable = true;
    f.style.opacity = "1";
  });
  document.getElementById("startBtn").disabled = true;

  faces.forEach(face => {
    face.addEventListener('dragstart', e => {
      if (face.classList.contains("used")) {
        e.preventDefault();
        return;
      }
      e.dataTransfer.setData('text/plain', face.dataset.index);
      e.dataTransfer.effectAllowed = "move";
    });
  });

  zones.forEach(zone => {
    zone.addEventListener('dragover', e => {
      e.preventDefault();
      zone.classList.add('dragover');
    });
    zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
    zone.addEventListener('drop', e => {
      e.preventDefault();
      zone.classList.remove('dragover');
      const newIndex = parseInt(e.dataTransfer.getData('text/plain'));
      if (isNaN(newIndex)) return;

      // If this zone already had a face assigned, free that one
      if (roleMap[zone.dataset.role] !== undefined) {
        const oldIndex = roleMap[zone.dataset.role];
        const oldFace = document.querySelector(`.face[data-index='${oldIndex}']`);
        if (oldFace) {
          oldFace.classList.remove("used");
          oldFace.draggable = true;
          oldFace.style.opacity = "1";
        }
      }

      // Unassign this new face from any other role it was previously linked to
      for (const role in roleMap) {
        if (roleMap[role] === newIndex && role !== zone.dataset.role) {
          delete roleMap[role];
          const oldZone = document.querySelector(`.drop-zone[data-role='${role}']`);
          if (oldZone) {
            oldZone.textContent = role === "question" ? "üß† C√¢u h·ªèi" :
                                  role === "answer" ? "üí¨ ƒê√°p √°n" :
                                  "üìò Gi·∫£i th√≠ch";
            oldZone.classList.remove("filled");
          }
        }
      }

      // Assign the new face to this role
      roleMap[zone.dataset.role] = newIndex;
      zone.textContent = `${zone.dataset.role.toUpperCase()} ‚Üê Face ${newIndex + 1}`;
      zone.classList.add("filled");

      // Mark the face as used
      const newFace = document.querySelector(`.face[data-index='${newIndex}']`);
      if (newFace) {
        newFace.classList.add("used");
        newFace.draggable = false;
        newFace.style.opacity = "0.5";
      }

      checkMappingComplete();
    });
  });

  // Reset button
  if (resetBtn) resetBtn.onclick = () => initDragDrop();
}

function checkMappingComplete() {
  const startBtn = document.getElementById("startBtn");
  const allChosen = ["question", "answer", "definition"]
    .every(r => roleMap[r] !== undefined);
  startBtn.disabled = !allChosen;
}

// Default mapping button
const defaultBtn = document.getElementById("defaultMappingBtn");
if (defaultBtn) {
  defaultBtn.onclick = () => {
    initDragDrop();
    roleMap = { question: 0, answer: 1, definition: 2 };

    const zones = document.querySelectorAll('.drop-zone');
    const faces = document.querySelectorAll('.face');

    zones.forEach(zone => {
      const idx = roleMap[zone.dataset.role];
      zone.textContent = `${zone.dataset.role.toUpperCase()} ‚Üê Face ${idx + 1}`;
      zone.classList.add('filled');
    });

    faces.forEach(face => {
      const idx = parseInt(face.dataset.index);
      if ([0,1,2].includes(idx)) {
        face.classList.add('used');
        face.draggable = false;
        face.style.opacity = "0.5";
      }
    });

    checkMappingComplete();
  };
}

function shuffle(arr) { return arr.sort(() => Math.random() - 0.5); }

function buildQuiz(data) {
  const quizContainer = document.getElementById("quiz");
  const scoreBox = document.getElementById("scoreBox");
  quizContainer.innerHTML = "";
  scoreBox.innerHTML = "";
  correctCountGlobal = 0;
  wrongQuestions = []; // reset each quiz run

  const limit = parseInt(document.getElementById("limitInput").value) || data.length;
  const totalQuestions = Math.min(limit, data.length);
  totalQuestionsGlobal = totalQuestions;

  // store the exact shuffled subset used in this quiz
  const selectedQuestions = shuffle([...data]).slice(0, totalQuestions);
  dataSet = selectedQuestions;

  const timeLimit = parseFloat(document.getElementById("timeInput").value);
  if (timeLimit > 0) {
    remainingSeconds = timeLimit * 60;
    quizStartTime = Date.now();
    document.getElementById("timerDisplay").style.display = "block";
    updateTimerDisplay();
    timerInterval = setInterval(() => {
      remainingSeconds--;
      updateTimerDisplay();
      if (remainingSeconds <= 0) endQuiz();
    }, 1000);
  } else {
    remainingSeconds = 0;
    document.getElementById("timerDisplay").style.display = "none";
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  }

  selectedQuestions.forEach(([question, correct, explanation], i) => {
    const box = document.createElement("div");
    box.className = "question-box";
    box.innerHTML = `<h2>Q${i+1}: ${question}</h2>`;
    let attemptLeft = parseInt(document.getElementById("attemptInputWriting").value) || 1;

    const input = document.createElement("input");
    input.className = "answer-input";
    input.placeholder = "Nh·∫≠p ƒë√°p √°n c·ªßa b·∫°n...";

    const btn = document.createElement("button");
    btn.className = "submit-btn";
    btn.textContent = "Tr·∫£ l·ªùi";

    // Allow pressing Enter to submit
    input.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        btn.click(); // trigger button click
      }
    });

    const feedback = document.createElement("div");
    feedback.className = "feedback";

    btn.onclick = () => {
      const answer = input.value.trim().toLowerCase();
      const correctAnswer = correct.trim().toLowerCase();

      if (!answer) {
          feedback.textContent = `üëé ƒê·ª´ng b·ªè tr·ªëng, con g√† üêî\nƒê√°p √°n ƒë√∫ng l√†: ${correct}\nGi·∫£i th√≠ch: ${explanation}`;
          feedback.style.color = "#ff6600";
          input.style.backgroundColor = "#3a3200";
          input.style.borderColor = "#f1e432";
          input.style.color = "#f1e432";
          input.style.boxShadow = "0 0 10px rgba(241,228,50,0.4)";

          attemptLeft = 0;  // treat as fail

          // save blank as wrong
          wrongQuestions.push({
              question,
              correct,
              explanation
          });

          input.disabled = true;
          btn.disabled = true;
      } else if (answer === correctAnswer) {
        feedback.textContent = `‚úÖ Ch√≠nh x√°c!\nGi·∫£i th√≠ch: ${explanation}`;
        feedback.style.color = "#9ff2b8";
        input.style.backgroundColor = "#0f2e19";                         // dark green base
        input.style.borderColor = "#22c55e";                             // neon emerald border
        input.style.color = "#22c55e";                                   // green text
        input.style.boxShadow = "0 0 10px rgba(34,197,94,0.4)";           // neon glow
        correctCountGlobal++;
        input.disabled = true;
        btn.disabled = true;
      } else {

        attemptLeft--; // decrease attempts

        // play animation
        

        

        if (attemptLeft > 0) {
            input.classList.remove("shake-rotate-scale"); // restart animation
            void input.offsetWidth;                       // force DOM reflow
            input.classList.add("shake-rotate-scale");
            feedback.textContent = `‚ùå Sai r·ªìi!\n(${attemptLeft} l∆∞·ª£t th·ª≠ c√≤n l·∫°i)`;
            feedback.style.color = "red";

            input.style.backgroundColor = "#2b0f0f";
            input.style.borderColor = "#ef4444";
            input.style.color = "#ef4444";
            input.style.boxShadow = "0 0 10px rgba(239,68,68,0.4)";
        }
        else {
            feedback.textContent = `‚ùå H·∫øt l∆∞·ª£t!\nƒê√°p √°n ƒë√∫ng: ${correct}\nGi·∫£i th√≠ch: ${explanation}`;
            feedback.style.color = "red";

            input.style.backgroundColor = "#2b0f0f";
            input.style.borderColor = "#ef4444";
            input.style.color = "#ef4444";
            input.style.boxShadow = "0 0 10px rgba(239,68,68,0.4)";

            input.disabled = true;
            btn.disabled = true;

            // Save wrong question for review
            wrongQuestions.push({
              question,
              correct,
              explanation
            });
        }
      }

      // Move to next question ONLY IF correct or out of attempts
      if (answer === correctAnswer || attemptLeft <= 0) {
          const allQuestions = document.querySelectorAll(".question-box");
          const currentIndex = Array.from(allQuestions).indexOf(box);
          const nextBox = allQuestions[currentIndex + 1];

          if (nextBox) {
              const rect = nextBox.getBoundingClientRect();
              const completelyAbove = rect.bottom < 0;
              const completelyBelow = rect.top > window.innerHeight;

              if (completelyAbove || completelyBelow) {
                  const targetY = rect.top + window.scrollY - 20; // <-- change -20 to adjust offset
                  window.scrollTo({ top: targetY, behavior: "smooth" });
              }

              setTimeout(() => {
                  const nextInput = nextBox.querySelector("input.answer-input");
                  if (nextInput && !nextInput.disabled) nextInput.focus();
              }, 600);
          }
      } else {
          // Still has attempts ‚Äî stay and focus same input
          setTimeout(() => {
              input.focus();
              input.setSelectionRange(input.value.length, input.value.length);
          }, 10);
      }

      // End quiz automatically if last question answered
      if (document.querySelectorAll(".submit-btn:not(:disabled)").length === 0) {
        endQuiz();
        document.getElementById("scoreBox").scrollIntoView({ behavior: "smooth", block: "center" });
      }
    };

    box.appendChild(input);
    box.appendChild(btn);
    box.appendChild(feedback);
    quizContainer.appendChild(box);
  });
}

function updateTimerDisplay() {
  const display = document.getElementById("timerDisplay");
  const mins = Math.floor(remainingSeconds / 60);
  const secs = remainingSeconds % 60;
  display.textContent = `‚è±Ô∏è ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

  // Flash red in last 10 seconds
  if (remainingSeconds <= 10) {
    display.style.backgroundColor = "#f8d7da";
    display.style.borderColor = "#dc3545";
    display.style.color = "#b30000";
  } else {
    display.style.backgroundColor = "#fff3cd";
    display.style.borderColor = "#ffc107";
    display.style.color = "#d9534f";
  }
}

function endQuiz() {
  clearInterval(timerInterval);
  timerInterval = null;
  quizEnded = true;

  const scoreBox = document.getElementById("scoreBox");
  const timerDisplay = document.getElementById("timerDisplay");
  timerDisplay.style.display = "none";

  const totalTime = ((Date.now() - quizStartTime) / 1000).toFixed(1);
  const percentage = Math.round((correctCountGlobal / totalQuestionsGlobal) * 100);

  // Determine time message
  const timeLimitInput = parseFloat(document.getElementById("timeInput").value);
  let timeMessage;
  if (timeLimitInput && remainingSeconds <= 0) {
    timeMessage = "YOU'RE TAKING TOO LONG üéÉ";
  } else {
    timeMessage = `Th·ªùi gian l√†m b√†i: ${totalTime} gi√¢y`;
  }

  // Score feedback
  let resultMessage = "";
  if (percentage >= 75) {
    resultMessage = `Final Score: ${correctCountGlobal}/${totalQuestionsGlobal} (${percentage}%). You‚Äôre a genius! üéâüéâ`;
  } else if (percentage >= 50 && percentage < 75) {
    resultMessage = `Final Score: ${correctCountGlobal}/${totalQuestionsGlobal} (${percentage}%). Congratulations! üéâ`;
  } else if (percentage > 0 && percentage < 50) {
    resultMessage = `Final Score: ${correctCountGlobal}/${totalQuestionsGlobal} (${percentage}%). We Asians are disappointed in you üò°üëø`;
  } else {
    resultMessage = `ARE YOU DUMB?`;
  }

  // Detect unanswered questions (only from dataSet i.e. selectedQuestions)
  const allBoxes = document.querySelectorAll(".question-box");
  allBoxes.forEach((box, i) => {
      const input = box.querySelector(".answer-input");
      const btn = box.querySelector(".submit-btn");

      // If still enabled ‚Üí the user NEVER answered this question
      if (!btn.disabled && !input.disabled) {
          const qText = dataSet[i][0];
          const correctAns = dataSet[i][1];
          const explain = dataSet[i][2];

          wrongQuestions.push({
              question: qText,
              correct: correctAns,
              explanation: explain
          });
      }
  });

  // Build score box AFTER wrongQuestions is populated
  scoreBox.innerHTML = `${resultMessage}<br>${timeMessage}`;
  scoreBox.style.display = "block";

  if (wrongQuestions.length > 0) {
      scoreBox.innerHTML += `
          <br><br>
          <button id="retryWrongBtn" class="yellow-btn">
              üîÅ L√†m l·∫°i c√¢u sai (${wrongQuestions.length})
          </button>
      `;

      setTimeout(() => {
          const btn = document.getElementById("retryWrongBtn");
          if (btn) btn.onclick = () => retryWrongQuestions();
      }, 50);
  }
}

function retryWrongQuestions() {
    if (!wrongQuestions || wrongQuestions.length === 0) return;

    // copy & shuffle the questions we will retry
    const toRetry = wrongQuestions
        .map(q => [q.question, q.correct, q.explanation])
        .sort(() => Math.random() - 0.5);

    // reset old UI
    document.getElementById("quiz").innerHTML = "";
    document.getElementById("scoreBox").innerHTML = "";
    document.getElementById("scoreBox").style.display = "none";

    // clear global store AFTER copying toRetry
    wrongQuestions = [];

    // build quiz again using only the toRetry data
    buildQuiz(toRetry);
}

document.getElementById("csvFile").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    lastCSVData = ev.target.result;
    fileNameGlobal = file.name.replace(/\.csv$/i, "").replace(/`/g, '"');
    document.getElementById("importStatus").innerHTML = `ƒê√£ t·∫£i l√™n: <span style="font-style:italic;">${file.name}</span> ‚úÖ`;
    document.getElementById("columnSelector").style.display = "block";
    document.getElementById("startBtn").style.display = "inline-block";
    document.getElementById("startBtn").disabled = true; // wait for drag-drop
    initDragDrop();
    document.getElementById("startBtn").style.display = "inline-block";
  };
  reader.readAsText(file);
});

document.getElementById("startBtn").addEventListener("click", () => {
    const mainTitle = document.getElementById("mainTitle");
    mainTitle.textContent = fileNameGlobal || "√îN T·∫¨P FLASHCARD 3 M·∫∂T (T·ª∞ LU·∫¨N)";
    mainTitle.style.textAlign = "center";
    mainTitle.style.marginBottom = "20px";
    mainTitle.style.display = "block";

  if (lastCSVData) {
    document.getElementById("setupSection").style.display = "none";
    const parsed = parseCSV(lastCSVData);
      const qIndex = roleMap.question ?? 0;
      const aIndex = roleMap.answer ?? 1;
      const dIndex = roleMap.definition ?? 2;
      const remapped = parsed.map(r => [r[qIndex], r[aIndex], r[dIndex]]);
      document.getElementById("columnSelector").style.display = "none";
      buildQuiz(remapped);
    document.getElementById("resetBtn").style.display = "inline-block";
    document.getElementById("replayBtn").style.display = "inline-block";
  }
});

document.getElementById("replayBtn").addEventListener("click", () => {
  if (!lastCSVData) return;

  // overlay
  const overlay = document.createElement("div");
  overlay.id = "replayOverlay";
  Object.assign(overlay.style, {
    position: "fixed",
    top: 0, left: 0, width: "100%", height: "100%",
    backgroundColor: "rgba(0,0,0,0.4)",
    zIndex: 1999
  });
  document.body.appendChild(overlay);

  // popup
  const popup = document.createElement("div");
  Object.assign(popup.style, {
    position: "fixed",
    top: "50%", left: "50%",
    transform: "translate(-50%, -50%)",
    background: "var(--surface)",
    padding: "20px 25px",
    borderRadius: "10px",
    boxShadow: "0 4px 10px rgba(0,0,0,0.3)",
    zIndex: 2000,
    textAlign: "center",
    maxHeight: "90vh",
    overflowY: "auto"
  });

  popup.innerHTML = `
    <h3>üîÅ Ch∆°i l·∫°i</h3>
    <label>S·ªë c√¢u h·ªèi:</label><br>
    <input type="number" id="replayLimit" min="1" value="${document.getElementById("limitInput").value || ''}" style="width:80px; margin:5px;"><br>
    <label>Th·ªùi gian l√†m b√†i (ph√∫t):</label><br>
    <input type="number" id="replayTime" min="0.1" step="0.1" value="${document.getElementById("timeInput").value || ''}" style="width:80px; margin:5px;"><br><br>
    <label>S·ªë l·∫ßn th·ª≠ m·ªói c√¢u:</label><br>
    <input type="number" id="replayAttempts" min="1"
           value="${document.getElementById("attemptInputWriting").value}"
           style="width:80px; margin:5px;"><br><br>

    <div id="popupFaces" style="display:flex; gap:10px; justify-content:center; margin-bottom:10px;">
      <div class="popup-face" draggable="true" data-index="0">Face 1</div>
      <div class="popup-face" draggable="true" data-index="1">Face 2</div>
      <div class="popup-face" draggable="true" data-index="2">Face 3</div>
    </div>

    <div id="popup-face" style="display:flex; flex-wrap:wrap; gap:15px; justify-content:center;">
      <div class="popup-zone" data-role="question">üß† C√¢u h·ªèi</div>
      <div class="popup-zone" data-role="answer">üí¨ ƒê√°p √°n</div>
      <div class="popup-zone" data-role="definition">üìò Gi·∫£i th√≠ch</div>
    </div>
    <br>
    <div style="margin-top:10px;">
      <button id="popupDefault" >‚úÖ Default Mapping</button>
      <button id="popupReset">üîÅ Reset Mapping</button>
    </div>

    <br><br>
    <button id="confirmReplay" title = "Gh√©p h·∫øt c√°c m·∫∑t ƒë·ªÅ b·∫Øt ƒë·∫ßu">B·∫Øt ƒë·∫ßu l·∫°i</button>
    <button id="cancelReplay">H·ªßy</button>
  `;
  document.body.appendChild(popup);

  // local map for popup
  const localMap = {};

  function checkComplete() {
    const btn = document.getElementById("confirmReplay");
    const complete = ["question","answer","definition"].every(r => localMap[r] !== undefined);
    btn.disabled = !complete;
  }

  function resetMapping() {
    Object.keys(localMap).forEach(k => delete localMap[k]);
    popup.querySelectorAll(".popup-zone").forEach(z=>{
      z.classList.remove("filled");
      z.textContent = z.dataset.role==="question"?"üß† C√¢u h·ªèi":
                      z.dataset.role==="answer"?"üí¨ ƒê√°p √°n":"üìò Gi·∫£i th√≠ch";
    });
    popup.querySelectorAll(".popup-face").forEach(f=>{
      f.classList.remove("used");
      f.draggable = true;
      f.style.opacity="1";
    });
    checkComplete();
  }

  // drag/drop in popup
  const faces = popup.querySelectorAll(".popup-face");
  const zones = popup.querySelectorAll(".popup-zone");

  faces.forEach(face=>{
    face.addEventListener("dragstart",e=>{
      if(face.classList.contains("used")){ e.preventDefault(); return; }
      e.dataTransfer.setData("text/plain", face.dataset.index);
    });
  });

  zones.forEach(zone=>{
    zone.addEventListener("dragover", e=>{
      e.preventDefault();
      zone.classList.add("dragover");
    });
    zone.addEventListener("dragleave", ()=>zone.classList.remove("dragover"));
    zone.addEventListener("drop", e=>{
      e.preventDefault();
      zone.classList.remove("dragover");
      const newIndex=parseInt(e.dataTransfer.getData("text/plain"));
      if(isNaN(newIndex)) return;

      // Free previous face if this zone had one
      if(localMap[zone.dataset.role]!==undefined){
        const oldIndex=localMap[zone.dataset.role];
        const oldFace=popup.querySelector(`.popup-face[data-index='${oldIndex}']`);
        if(oldFace){ oldFace.classList.remove("used"); oldFace.draggable=true; oldFace.style.opacity="1"; }
      }

      // Unassign this new face from other roles
      for(const role in localMap){
        if(localMap[role]===newIndex && role!==zone.dataset.role){
          delete localMap[role];
          const otherZone=popup.querySelector(`.popup-zone[data-role='${role}']`);
          if(otherZone){
            otherZone.classList.remove("filled");
            otherZone.textContent=role==="question"?"üß† C√¢u h·ªèi":role==="answer"?"üí¨ ƒê√°p √°n":"üìò Gi·∫£i th√≠ch";
          }
        }
      }

      // Assign face
      localMap[zone.dataset.role]=newIndex;
      zone.classList.add("filled");
      zone.textContent=`${zone.dataset.role.toUpperCase()} ‚Üê Face ${newIndex+1}`;

      // Mark face used
      const newFace=popup.querySelector(`.popup-face[data-index='${newIndex}']`);
      if(newFace){ newFace.classList.add("used"); newFace.draggable=false; newFace.style.opacity="0.5"; }

      checkComplete();
    });
  });

  document.getElementById("popupReset").onclick = resetMapping;
  document.getElementById("popupDefault").onclick = () => {
    resetMapping();
    const defaultOrder = { question: 0, answer: 1, definition: 2 };
    Object.entries(defaultOrder).forEach(([role, index]) => {
      const zone = popup.querySelector(`.popup-zone[data-role='${role}']`);
      const face = popup.querySelector(`.popup-face[data-index='${index}']`);
      localMap[role] = index;
      zone.classList.add("filled");
      zone.textContent = `${zone.dataset.role.toUpperCase()} ‚Üê Face ${index + 1}`;
      face.classList.add("used");
      face.draggable = false;
      face.style.opacity = "0.5";
    });
    checkComplete();
  };

  // confirm/hide
  const closePopup=()=>{
    document.removeEventListener("keydown",keyHandler);
    popup.remove(); overlay.remove();
  };
  const startReplay=()=>{
    // handle blank rules:
    const replayLimitEl = document.getElementById("replayLimit");
    const replayTimeEl = document.getElementById("replayTime");
    const replayAttemptsEl = document.getElementById("replayAttempts");

    // If replayLimit blank -> full dataset (use remapped length)
    if (replayLimitEl.value.trim() === "") {
      document.getElementById("limitInput").value = parseInt((parseCSV(lastCSVData).length)) || "";
    } else {
      const newLimit = parseInt(replayLimitEl.value);
      if (!isNaN(newLimit)) document.getElementById("limitInput").value = newLimit;
    }

    // If replayTime blank -> disable timer (set to 0)
    if (replayTimeEl.value.trim() === "") {
      document.getElementById("timeInput").value = 0;
    } else {
      const newTime = parseFloat(replayTimeEl.value);
      if (!isNaN(newTime)) document.getElementById("timeInput").value = newTime;
    }

    // Attempts: if provided, update; if blank -> keep current value
    if (replayAttemptsEl.value.trim() !== "") {
      const newAttempts = parseInt(replayAttemptsEl.value);
      if (!isNaN(newAttempts)) {
        document.getElementById("attemptInputWriting").value = newAttempts;
      }
    }

    document.getElementById("quiz").innerHTML="";
    document.getElementById("scoreBox").textContent="";
    document.getElementById("timerDisplay").style.display="none";
    clearInterval(timerInterval); timerInterval=null;
    quizEnded=false; correctCountGlobal=0; totalQuestionsGlobal=0;

    const parsed=parseCSV(lastCSVData);
    const qIndex=localMap.question??0;
    const aIndex=localMap.answer??1;
    const dIndex=localMap.definition??2;
    const remapped=parsed.map(r=>[r[qIndex],r[aIndex],r[dIndex]]);

    closePopup();
    buildQuiz(remapped);
  };

  const keyHandler=(e)=>{
    if(e.key==="Enter"){ e.preventDefault(); startReplay(); }
    else if(e.key==="Escape"){ e.preventDefault(); closePopup(); }
  };
  document.addEventListener("keydown",keyHandler);

  document.getElementById("confirmReplay").onclick=startReplay;
  document.getElementById("cancelReplay").onclick=closePopup;

  // initial state
  resetMapping();
  setTimeout(()=>document.getElementById("replayLimit").focus(),100);
});

document.getElementById("resetBtn").addEventListener("click", () => location.reload());
</script>
</body>
</html>
